<!doctype html>
<html lang='fr'>
<head>
  <meta charset='utf-8' />
  <meta name='viewport' content='width=device-width,initial-scale=1' />
  <title>Point le plus haut — OSM + SRTM</title>

  <script src='https://cdn.tailwindcss.com'></script>
  <link rel='stylesheet' href='https://unpkg.com/leaflet@1.9.4/dist/leaflet.css'/>
  <link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css'/>
  <style>
    html,body,#map { height: 100%; margin: 0; padding: 0; }
    .leaflet-control-container .leaflet-top { z-index: 1100; }
  </style>
</head>
<body class='bg-slate-50 text-slate-800'>
  <div class='flex h-screen'>
    <aside id='sidebar' class='w-96 p-4 border-r bg-white shadow-md z-20'>
      <div class='flex items-center justify-between mb-4'>
        <h1 class='text-lg font-semibold'>Trouver le point le plus haut</h1>
        <div class='text-sm text-slate-500'>FR — par défaut : <span id='styleDefault'>Pro</span></div>
      </div>

      <div class='space-y-3'>
        <div>
          <label class='block text-sm font-medium'>Rechercher un lieu</label>
          <div class='flex gap-2 mt-2'>
            <input id='searchInput' class='flex-1 px-3 py-2 border rounded' placeholder='Ville, adresse ou lieu...' />
            <button id='searchBtn' class='px-3 py-2 bg-blue-600 text-white rounded'>Rechercher</button>
          </div>
          <div id='searchResults' class='mt-2 text-xs text-slate-600'></div>
        </div>

        <div>
          <label class='block text-sm font-medium'>Sélection (dessine un rectangle)</label>
          <p class='text-xs text-slate-500 mt-1'>Utilise l'outil de dessin sur la carte à droite. Garde une seule sélection active.</p>
        </div>

        <div class='pt-2 border-t'>
          <label class='inline-flex items-center'>
            <input id='useGrid' type='checkbox' class='mr-2' />
            <span class='text-sm'>Échantillonner la zone avec SRTM si OSM n'a pas d'élévation</span>
          </label>
          <div class='mt-2 flex items-center gap-2'>
            <label class='text-xs'>Résolution</label>
            <input id='gridSize' type='number' min='6' max='80' value='15' class='w-20 px-2 py-1 border rounded' />
            <span class='text-xs text-slate-500'>(plus = plus précis)</span>
          </div>

          <label class='inline-flex items-center mt-3'>
            <input id='mergeOSMTop' type='checkbox' class='mr-2' checked />
            <span class='text-sm'>Fusionner OSM + SRTM (préférence OSM si disponible)</span>
          </label>

          <label class='inline-flex items-center mt-3'>
            <input id='filterOutliers' type='checkbox' class='mr-2' checked />
            <span class='text-sm'>Filtrer les valeurs aberrantes (tolérance automatique)</span>
          </label>
        </div>

        <div class='pt-2 border-t'>
          <label class='block text-sm font-medium'>Style</label>
          <div class='mt-2 grid grid-cols-3 gap-2'>
            <button class='styleBtn px-2 py-2 rounded border' data-style='Pro'>Pro</button>
            <button class='styleBtn px-2 py-2 rounded border' data-style='Nature'>Nature</button>
            <button class='styleBtn px-2 py-2 rounded border' data-style='Dark'>Dark</button>
          </div>
        </div>

        <div class='pt-2 border-t'>
          <div class='flex gap-2'>
            <button id='locateBtn' class='flex-1 px-3 py-2 rounded bg-emerald-600 text-white'>Ma position</button>
            <button id='resetBtn' class='px-3 py-2 rounded border'>Reset</button>
          </div>

          <div class='mt-3 grid grid-cols-2 gap-2'>
            <button id='findBtn' class='px-3 py-2 bg-blue-600 text-white rounded'>Trouver le point le plus haut</button>
            <button id='exportBtn' class='px-3 py-2 bg-slate-700 text-white rounded'>Exporter (CSV / GeoJSON)</button>
          </div>

          <div id='status' class='mt-3 text-sm font-medium'>Prêt.</div>
          <div id='log' class='mt-2 text-xs text-slate-600 max-h-36 overflow-auto'></div>
        </div>

        <div class='pt-2 border-t text-xs text-slate-500'>
          <strong>Hébergement :</strong> tu peux héberger sur GitHub Pages (fichier unique index.html).
        </div>
      </div>
    <div class='pt-4 border-t mt-4'>
  <button onclick="window.print()" class='w-full px-3 py-2 rounded bg-indigo-600 text-white'>Imprimer l'aide</button>
</div>
</aside>

    <main class='flex-1 relative'>
      <div id='map' class='w-full h-full'></div>
    </main>
  </div>

  <script src='https://unpkg.com/leaflet@1.9.4/dist/leaflet.js'></script>
  <script src='https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js'></script>

  <script>
  const OVERPASS_URL = 'https://overpass-api.de/api/interpreter';
  const OPENTOPODATA_URL = 'https://api.opentopodata.org/v1/srtm90m';
  const NOMINATIM_URL = 'https://nominatim.openstreetmap.org/search?format=json&limit=6&q=';

  const map = L.map('map').setView([46.8, 2.4], 6);
  const baseLayers = { osm: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '© OpenStreetMap contributors' }) };
  baseLayers.osm.addTo(map);

  const drawnItems = new L.FeatureGroup();
  map.addLayer(drawnItems);
  const drawControl = new L.Control.Draw({ draw: { polygon:false, polyline:false, circle:false, marker:false, rectangle:{ shapeOptions:{ color:'#f06eaa' } } }, edit: { featureGroup: drawnItems } });
  map.addControl(drawControl);
  map.on(L.Draw.Event.CREATED, function(e){ drawnItems.clearLayers(); drawnItems.addLayer(e.layer); });

  const logEl = document.getElementById('log');
  function log(msg){ const now=new Date().toLocaleTimeString(); logEl.innerHTML = '<div>[' + now + '] ' + msg + '</div>' + logEl.innerHTML; }
  function setStatus(s){ document.getElementById('status').innerText = s; }

  const styleDefaultEl = document.getElementById('styleDefault');
  const styleBtns = document.querySelectorAll('.styleBtn');
  let currentStyle = 'Pro';
  styleBtns.forEach(function(b){ b.addEventListener('click', function(){ const s = b.dataset.style || 'Pro'; applyStyle(s); }); });
  function applyStyle(styleName){ currentStyle = styleName; styleDefaultEl.innerText = styleName; if (styleName === 'Pro'){ document.body.className = 'bg-slate-50 text-slate-800'; } else if (styleName === 'Nature'){ document.body.className = 'bg-emerald-50 text-emerald-900'; } else if (styleName === 'Dark'){ document.body.className = 'bg-slate-900 text-slate-200'; } log('Style appliqué: ' + styleName); }
  applyStyle('Pro');

  const searchInput = document.getElementById('searchInput');
  const searchBtn = document.getElementById('searchBtn');
  const searchResultsEl = document.getElementById('searchResults');
  let lastSearchMarker = null;

  searchBtn.addEventListener('click', async function(){ const q = searchInput.value.trim(); if (!q) return; setStatus('Recherche Nominatim...'); try{ const r = await fetch(NOMINATIM_URL + encodeURIComponent(q), {headers:{'Accept':'application/json'}}); const j = await r.json(); searchResultsEl.innerHTML = ''; if (j.length === 0) { searchResultsEl.innerText = 'Aucun résultat.'; setStatus('Prêt.'); return; } j.forEach(function(it){ const btn = document.createElement('button'); btn.className = 'w-full text-left px-2 py-1 hover:bg-slate-100 rounded text-sm'; btn.innerText = it.display_name + ' (' + it.lat + ', ' + it.lon + ')'; btn.addEventListener('click', function(){ if (lastSearchMarker) map.removeLayer(lastSearchMarker); lastSearchMarker = L.marker([it.lat, it.lon]).addTo(map).bindPopup(it.display_name).openPopup(); map.setView([it.lat, it.lon], 13); searchResultsEl.innerHTML = ''; setStatus('Prêt.'); }); searchResultsEl.appendChild(btn); }); }catch(e){ log('Erreur Nominatim: ' + e.message); setStatus('Erreur Nominatim'); } });

  document.getElementById('locateBtn').addEventListener('click', function(){ map.locate({setView:true, maxZoom:13}); });
  document.getElementById('resetBtn').addEventListener('click', function(){ drawnItems.clearLayers(); if (resultMarker) map.removeLayer(resultMarker); setStatus('Reset.'); log('Sélection et résultats réinitialisés.'); });
  document.getElementById('exportBtn').addEventListener('click', function(){ if (!lastResult) { alert('Aucun résultat à exporter.'); return; } exportResult(lastResult); });

  document.getElementById('findBtn').addEventListener('click', async function(){ if (drawnItems.getLayers().length === 0) { alert('Dessine d\'abord un rectangle.'); return; } drawnItems.eachLayer(function(layer){ const bounds = layer.getBounds(); processBBox(bounds); }); });

  let resultMarker = null;
  let lastResult = null;

  async function processBBox(bounds){ setStatus('Requête Overpass — recherche nodes avec ele / natural=peak'); log('Envoi requête Overpass pour la zone'); const s = bounds.getSouth(), w = bounds.getWest(), n = bounds.getNorth(), e = bounds.getEast(); const query = '[out:json][timeout:60]; ( node["natural"="peak"](' + s + ',' + w + ',' + n + ',' + e + '); node["ele"](' + s + ',' + w + ',' + n + ',' + e + '); ); out body;'; try{ const resp = await fetch(OVERPASS_URL, {method:'POST', headers:{'Content-Type':'application/x-www-form-urlencoded; charset=UTF-8'}, body:'data=' + encodeURIComponent(query)}); if (!resp.ok) throw new Error('Overpass HTTP ' + resp.status); const data = await resp.json(); log('Overpass: ' + data.elements.length + ' éléments retournés.');

    let osmHighest = null;
    data.elements.forEach(function(el){ if (el.type !== 'node') return; const tags = el.tags || {}; if (tags.ele !== undefined){ const cleaned = tags.ele.toString().replace(',', '.'); // only use digits, dot and minus
        let numStr = '';
        for (let i = 0; i < cleaned.length; i++){ const ch = cleaned.charAt(i); if ((ch >= '0' && ch <= '9') || ch === '.' || ch === '-') numStr += ch; }
        const num = parseFloat(numStr);
        if (!isNaN(num)){ if (!osmHighest || num > osmHighest.ele) osmHighest = {ele:num, lat:el.lat, lon:el.lon, name:tags.name || 'Inconnu', osm_id:el.id}; }
    } });

    const useGrid = document.getElementById('useGrid').checked;
    const gridSize = Math.max(6, Math.min(80, parseInt(document.getElementById('gridSize').value) || 15));
    const mergeOSMTop = document.getElementById('mergeOSMTop').checked;
    const filterOutliers = document.getElementById('filterOutliers').checked;

    if (osmHighest && !useGrid){ log('Point trouvé via OSM (ele).'); setStatus('Point trouvé via OSM.'); showResult(osmHighest, 'OSM (tag ele)'); lastResult = {source:'OSM', data:osmHighest}; return; }

    let topoHighest = null;
    if (useGrid){ setStatus('Échantillonnage SRTM — génération grille'); log('Échantillonnage ' + gridSize + 'x' + gridSize); const latStep = (n - s) / (gridSize - 1); const lonStep = (e - w) / (gridSize - 1); const locs = []; for (let i = 0; i < gridSize; i++){ for (let j = 0; j < gridSize; j++){ locs.push([ (s + i * latStep).toFixed(6), (w + j * lonStep).toFixed(6) ]); } }

      const batchSize = 80;
      for (let idx = 0; idx < locs.length; idx += batchSize){ const batch = locs.slice(idx, idx + batchSize); let locationsParam = ''; for (let k = 0; k < batch.length; k++){ if (k) locationsParam += '|'; locationsParam += batch[k][0] + ',' + batch[k][1]; }
        const url = OPENTOPODATA_URL + '?locations=' + encodeURIComponent(locationsParam);
        log('Requête OpenTopoData ' + (idx + 1) + '/' + locs.length);
        const r = await fetch(url);
        if (!r.ok){ log('OpenTopoData erreur ' + r.status); setStatus('Erreur OpenTopoData'); return; }
        const jr = await r.json(); if (!jr.results){ log('OpenTopoData réponse inattendue'); setStatus('Erreur OpenTopoData'); return; }
        jr.results.forEach(function(res){ if (res && typeof res.elevation === 'number'){ if (!topoHighest || res.elevation > topoHighest.ele) topoHighest = {ele:res.elevation, lat:res.location[0], lon:res.location[1]}; } });
        await new Promise(function(rr){ setTimeout(rr, 250); }); }
      if (topoHighest) log('Point estimé SRTM: ' + topoHighest.ele + ' m'); }

    let final = null;
    if (osmHighest && topoHighest){ if (mergeOSMTop){ final = osmHighest; final._note = 'OSM préféré (fusion)'; } else { final = (osmHighest.ele >= topoHighest.ele) ? osmHighest : topoHighest; final._note = 'Choix par altitude brute'; } } else if (osmHighest){ final = osmHighest; final._note = 'OSM seul'; } else if (topoHighest){ final = topoHighest; final._note = 'SRTM seul'; }

    if (!final){ setStatus('Aucun résultat d\'élévation trouvé.'); log('Aucun élévation'); return; }

    if (filterOutliers && topoHighest && osmHighest){ if (Math.abs(topoHighest.ele - osmHighest.ele) > 300){ log('Différence importante entre OSM et SRTM — écart > 300m. Conservation de OSM par sécurité.'); final = osmHighest; } }

    showResult(final, final._note || 'Calcul'); lastResult = {source:final._note || 'calcul', data:final}; setStatus('Terminé.');

  }catch(err){ console.error(err); setStatus('Erreur: ' + err.message); log('Erreur: ' + err.message); } }

  function showResult(res, sourceLabel){ if (resultMarker) map.removeLayer(resultMarker); const lat = parseFloat(res.lat), lon = parseFloat(res.lon); resultMarker = L.marker([lat, lon]).addTo(map); const popup = '<div class="min-w-[220px]"><b>' + (res.name || 'Point') + '</b><br/><b>Altitude:</b> ' + res.ele + ' m<br/><b>Source:</b> ' + sourceLabel + '<br/><b>Coord:</b> ' + lat.toFixed(6) + ', ' + lon.toFixed(6) + '</div>'; resultMarker.bindPopup(popup).openPopup(); map.setView([lat, lon], 13); log('Résultat: ' + res.ele + ' m — ' + sourceLabel); }

  function exportResult(result){ const csvRows = [['name','ele','lat','lon','source']]; csvRows.push([ (result.data.name||'Point'), result.data.ele, result.data.lat, result.data.lon, result.source ]); let csvContent = ''; for (let i=0;i<csvRows.length;i++){ const row = csvRows[i].map(function(v){ return '"' + String(v).replace(/"/g, '""') + '"'; }).join(','); csvContent += row + '
'; } const csvBlob = new Blob([csvContent], {type:'text/csv;charset=utf-8;'}); const csvUrl = URL.createObjectURL(csvBlob); const a1 = document.createElement('a'); a1.href = csvUrl; a1.download = 'highest_point.csv'; a1.click(); const geo = { type: 'FeatureCollection', features: [ { type:'Feature', properties:{ name: result.data.name||'Point', ele: result.data.ele, source: result.source }, geometry:{ type:'Point', coordinates:[parseFloat(result.data.lon), parseFloat(result.data.lat)] } } ] }; const geoBlob = new Blob([JSON.stringify(geo, null, 2)], {type:'application/json'}); const geoUrl = URL.createObjectURL(geoBlob); const a2 = document.createElement('a'); a2.href = geoUrl; a2.download = 'highest_point.geojson'; a2.click(); log('Export CSV + GeoJSON générés'); }

  log('Application prête. Dessine un rectangle puis clique sur "Trouver le point le plus haut".');
  setStatus('Prêt.');
  </script>
</body>
</html>
